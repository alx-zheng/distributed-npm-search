{"type":"object","value":{"https://www.npmjs.com/package/minisearch":"{\"type\":\"string\",\"value\":\"skip to:contentpackage searchsign in\\n❤\\n * Pro [/products/pro]\\n * Teams [/products/teams]\\n * Pricing [/products]\\n * Documentation [https://docs.npmjs.com]\\n\\nnpm\\n/\\n\\nSearch\\nSign Up [/signup]Sign In [/login]\\n\\n\\nMINISEARCH\\nTypeScript icon, indicating that this package has built-in type declarations\\n[https://static-production.npmjs.com/255a118f56f5346b97e56325a1217a16.svg]\\n\\n6.3.0 • Public • Published 5 months ago\\n * Readme [?activeTab=readme]\\n * Code Beta [?activeTab=code]\\n * 0 Dependencies [?activeTab=dependencies]\\n * 94 Dependents [?activeTab=dependents]\\n * 77 Versions [?activeTab=versions]\\n\\n\\nMINISEARCH\\n\\nCI Build\\n[https://github.com/lucaong/minisearch/workflows/CI%20Build/badge.svg]https://github.com/lucaong/minisearch/actions\\nCoverage Status\\n[https://camo.githubusercontent.com/f92b0550c5b134f8b68765cd0eaf2762bbaf55a7761dad8df244e53c753440b9/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6c7563616f6e672f6d696e697365617263682f62616467652e7376673f6272616e63683d6d6173746572]https://coveralls.io/github/lucaong/minisearch?branch=master\\nMinzipped Size\\n[https://camo.githubusercontent.com/b7b78c464978628a48764a0fde3509e8ebf14d3472dd2eb39518ef2e9d30176f/68747470733a2f2f62616467656e2e6e65742f62756e646c6570686f6269612f6d696e7a69702f6d696e69736561726368]https://bundlephobia.com/result?p=minisearch\\nnpm\\n[https://camo.githubusercontent.com/8005db0e0c0ce117cf5e7db08fb2e751e28ad2a02e434902b755dc60ccb8fcf8/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f6d696e697365617263683f636f6c6f723d253233666630306464]https://www.npmjs.com/package/minisearch\\nnpm downloads\\n[https://camo.githubusercontent.com/ed3d1aae01244e64a4354086889a5a5532891a3642c7c98d733bc3a196e251a6/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f64772f6d696e69736561726368]https://www.npmjs.com/package/minisearch\\ntypes\\n[https://camo.githubusercontent.com/820ca4704cd9f87bc17fd08f4b1847366981d091f8ecd266aa77df0d00b24bda/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f74797065732f6d696e69736561726368]https://lucaong.github.io/minisearch/classes/MiniSearch.MiniSearch.html\\n\\nMiniSearch is a tiny but powerful in-memory fulltext search engine written in\\nJavaScript. It is respectful of resources, and it can comfortably run both in\\nNode and in the browser.\\n\\nTry out the demo application [https://lucaong.github.io/minisearch/demo/].\\n\\nFind the complete documentation and API reference here\\n[https://lucaong.github.io/minisearch/classes/MiniSearch.MiniSearch.html], and\\nmore background about MiniSearch, including a comparison with other similar\\nlibraries, in this blog post\\n[https://lucaongaro.eu/blog/2019/01/30/minisearch-client-side-fulltext-search-engine.html].\\n\\nMiniSearch follows semantic versioning [https://semver.org/spec/v2.0.0.html],\\nand documents releases and changes in the changelog\\n[https://github.com/lucaong/minisearch/blob/master/CHANGELOG.md].\\n\\n\\nUSE CASE\\n\\nMiniSearch addresses use cases where full-text search features are needed (e.g.\\nprefix search, fuzzy search, ranking, boosting of fields…), but the data to be\\nindexed can fit locally in the process memory. While you won't index the whole\\nInternet with it, there are surprisingly many use cases that are served well by\\nMiniSearch. By storing the index in local memory, MiniSearch can work offline,\\nand can process queries quickly, without network latency.\\n\\nA prominent use-case is real time search \\\"as you type\\\" in web and mobile\\napplications, where keeping the index on the client enables fast and reactive\\nUIs, removing the need to make requests to a search server.\\n\\n\\nFEATURES\\n\\n * Memory-efficient index, designed to support memory-constrained use cases like\\n   mobile browsers.\\n\\n * Exact match, prefix search, fuzzy match, field boosting.\\n\\n * Auto-suggestion engine, for auto-completion of search queries.\\n\\n * Modern search result ranking algorithm.\\n\\n * Documents can be added and removed from the index at any time.\\n\\n * Zero external dependencies.\\n\\nMiniSearch strives to expose a simple API that provides the building blocks to\\nbuild custom solutions, while keeping a small and well tested codebase.\\n\\n\\nINSTALLATION\\n\\nWith npm:\\n\\nnpm install minisearch\\n\\n\\nWith yarn:\\n\\nyarn add minisearch\\n\\n\\nThen require or import it in your project:\\n\\n// If you are using import:\\nimport MiniSearch from 'minisearch'\\n\\n// If you are using require:\\nconst MiniSearch = require('minisearch')\\n\\nAlternatively, if you prefer to use a <script> tag, you can require MiniSearch\\nfrom a CDN [https://www.jsdelivr.com/package/npm/minisearch]:\\n\\n<script src=\\\"https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js\\\"></script>\\n\\nIn this case, MiniSearch will appear as a global variable in your project.\\n\\nFinally, if you want to manually build the library, clone the repository and run\\nyarn build (or yarn build-minified for a minified version + source maps). The\\ncompiled source will be created in the dist folder (UMD, ES6 and ES2015 module\\nversions are provided).\\n\\n\\nUSAGE\\n\\n\\nBASIC USAGE\\n\\n// A collection of documents for our examples\\nconst documents = [\\n  {\\n    id: 1,\\n    title: 'Moby Dick',\\n    text: 'Call me Ishmael. Some years ago...',\\n    category: 'fiction'\\n  },\\n  {\\n    id: 2,\\n    title: 'Zen and the Art of Motorcycle Maintenance',\\n    text: 'I can see by my watch...',\\n    category: 'fiction'\\n  },\\n  {\\n    id: 3,\\n    title: 'Neuromancer',\\n    text: 'The sky above the port was...',\\n    category: 'fiction'\\n  },\\n  {\\n    id: 4,\\n    title: 'Zen and the Art of Archery',\\n    text: 'At first sight it must seem...',\\n    category: 'non-fiction'\\n  },\\n  // ...and more\\n]\\n\\nlet miniSearch = new MiniSearch({\\n  fields: ['title', 'text'], // fields to index for full-text search\\n  storeFields: ['title', 'category'] // fields to return with search results\\n})\\n\\n// Index all documents\\nminiSearch.addAll(documents)\\n\\n// Search with default options\\nlet results = miniSearch.search('zen art motorcycle')\\n// => [\\n//   { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', category: 'fiction', score: 2.77258, match: { ... } },\\n//   { id: 4, title: 'Zen and the Art of Archery', category: 'non-fiction', score: 1.38629, match: { ... } }\\n// ]\\n\\n\\nSEARCH OPTIONS\\n\\nMiniSearch supports several options for more advanced search behavior:\\n\\n// Search only specific fields\\nminiSearch.search('zen', { fields: ['title'] })\\n\\n// Boost some fields (here \\\"title\\\")\\nminiSearch.search('zen', { boost: { title: 2 } })\\n\\n// Prefix search (so that 'moto' will match 'motorcycle')\\nminiSearch.search('moto', { prefix: true })\\n\\n// Search within a specific category\\nminiSearch.search('zen', {\\n  filter: (result) => result.category === 'fiction'\\n})\\n\\n// Fuzzy search, in this example, with a max edit distance of 0.2 * term length,\\n// rounded to nearest integer. The mispelled 'ismael' will match 'ishmael'.\\nminiSearch.search('ismael', { fuzzy: 0.2 })\\n\\n// You can set the default search options upon initialization\\nminiSearch = new MiniSearch({\\n  fields: ['title', 'text'],\\n  searchOptions: {\\n    boost: { title: 2 },\\n    fuzzy: 0.2\\n  }\\n})\\nminiSearch.addAll(documents)\\n\\n// It will now by default perform fuzzy search and boost \\\"title\\\":\\nminiSearch.search('zen and motorcycles')\\n\\n\\nAUTO SUGGESTIONS\\n\\nMiniSearch can suggest search queries given an incomplete query:\\n\\nminiSearch.autoSuggest('zen ar')\\n// => [ { suggestion: 'zen archery art', terms: [ 'zen', 'archery', 'art' ], score: 1.73332 },\\n//      { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 } ]\\n\\nThe autoSuggest method takes the same options as the search method, so you can\\nget suggestions for misspelled words using fuzzy search:\\n\\nminiSearch.autoSuggest('neromancer', { fuzzy: 0.2 })\\n// => [ { suggestion: 'neuromancer', terms: [ 'neuromancer' ], score: 1.03998 } ]\\n\\nSuggestions are ranked by the relevance of the documents that would be returned\\nby that search.\\n\\nSometimes, you might need to filter auto suggestions to, say, only a specific\\ncategory. You can do so by providing a filter option:\\n\\nminiSearch.autoSuggest('zen ar', {\\n  filter: (result) => result.category === 'fiction'\\n})\\n// => [ { suggestion: 'zen art', terms: [ 'zen', 'art' ], score: 1.21313 } ]\\n\\n\\nFIELD EXTRACTION\\n\\nBy default, documents are assumed to be plain key-value objects with field names\\nas keys and field values as simple values. In order to support custom field\\nextraction logic (for example for nested fields, or non-string field values that\\nneed processing before tokenization), a custom field extractor function can be\\npassed as the extractField option:\\n\\n// Assuming that our documents look like:\\nconst documents = [\\n  { id: 1, title: 'Moby Dick', author: { name: 'Herman Melville' }, pubDate: new Date(1851, 9, 18) },\\n  { id: 2, title: 'Zen and the Art of Motorcycle Maintenance', author: { name: 'Robert Pirsig' }, pubDate: new Date(1974, 3, 1) },\\n  { id: 3, title: 'Neuromancer', author: { name: 'William Gibson' }, pubDate: new Date(1984, 6, 1) },\\n  { id: 4, title: 'Zen in the Art of Archery', author: { name: 'Eugen Herrigel' }, pubDate: new Date(1948, 0, 1) },\\n  // ...and more\\n]\\n\\n// We can support nested fields (author.name) and date fields (pubDate) with a\\n// custom `extractField` function:\\n\\nlet miniSearch = new MiniSearch({\\n  fields: ['title', 'author.name', 'pubYear'],\\n  extractField: (document, fieldName) => {\\n    // If field name is 'pubYear', extract just the year from 'pubDate'\\n    if (fieldName === 'pubYear') {\\n      const pubDate = document['pubDate']\\n      return pubDate && pubDate.getFullYear().toString()\\n    }\\n\\n    // Access nested fields\\n    return fieldName.split('.').reduce((doc, key) => doc && doc[key], document)\\n  }\\n})\\n\\nThe default field extractor can be obtained by calling\\nMiniSearch.getDefault('extractField').\\n\\n\\nTOKENIZATION\\n\\nBy default, documents are tokenized by splitting on Unicode space or punctuation\\ncharacters. The tokenization logic can be easily changed by passing a custom\\ntokenizer function as the tokenize option:\\n\\n// Tokenize splitting by hyphen\\nlet miniSearch = new MiniSearch({\\n  fields: ['title', 'text'],\\n  tokenize: (string, _fieldName) => string.split('-')\\n})\\n\\nUpon search, the same tokenization is used by default, but it is possible to\\npass a tokenize search option in case a different search-time tokenization is\\nnecessary:\\n\\n// Tokenize splitting by hyphen\\nlet miniSearch = new MiniSearch({\\n  fields: ['title', 'text'],\\n  tokenize: (string) => string.split('-'), // indexing tokenizer\\n  searchOptions: {\\n    tokenize: (string) => string.split(/[\\\\s-]+/) // search query tokenizer\\n  }\\n})\\n\\nThe default tokenizer can be obtained by calling\\nMiniSearch.getDefault('tokenize').\\n\\n\\nTERM PROCESSING\\n\\nTerms are downcased by default. No stemming is performed, and no stop-word list\\nis applied. To customize how the terms are processed upon indexing, for example\\nto normalize them, filter them, or to apply stemming, the processTerm option can\\nbe used. The processTerm function should return the processed term as a string,\\nor a falsy value if the term should be discarded:\\n\\nlet stopWords = new Set(['and', 'or', 'to', 'in', 'a', 'the', /* ...and more */ ])\\n\\n// Perform custom term processing (here discarding stop words and downcasing)\\nlet miniSearch = new MiniSearch({\\n  fields: ['title', 'text'],\\n  processTerm: (term, _fieldName) =>\\n    stopWords.has(term) ? null : term.toLowerCase()\\n})\\n\\nBy default, the same processing is applied to search queries. In order to apply\\na different processing to search queries, supply a processTerm search option:\\n\\nlet miniSearch = new MiniSearch({\\n  fields: ['title', 'text'],\\n  processTerm: (term) =>\\n    stopWords.has(term) ? null : term.toLowerCase(), // index term processing\\n  searchOptions: {\\n    processTerm: (term) => term.toLowerCase() // search query processing\\n  }\\n})\\n\\nThe default term processor can be obtained by calling\\nMiniSearch.getDefault('processTerm').\\n\\n\\nAPI DOCUMENTATION\\n\\nRefer to the API documentation\\n[https://lucaong.github.io/minisearch/classes/MiniSearch.MiniSearch.html] for\\ndetails about configuration options and methods.\\n\\n\\nBROWSER COMPATIBILITY\\n\\nMiniSearch natively supports all modern browsers implementing JavaScript\\nstandards, but requires a polyfill when used in Internet Explorer, as it makes\\nuse functions like Object.entries, Array.includes, and Array.from, which are\\nstandard but not available on older browsers. The package core-js\\n[https://github.com/zloirock/core-js] is one such polyfill that can be used to\\nprovide those functions.\\n\\n\\nCONTRIBUTING\\n\\nContributions to MiniSearch are welcome! Please read the contributions\\nguidelines [https://github.com/lucaong/minisearch/blob/master/CONTRIBUTING.md].\\nReading the design document\\n[https://github.com/lucaong/minisearch/blob/master/DESIGN_DOCUMENT.md] is also\\nuseful to understand the project goals and the technical implementation.\\n\\n\\nREADME\\n\\n\\nKEYWORDS\\n\\n * search [/search?q=keywords:search]\\n * full text [/search?q=keywords:full text]\\n * fuzzy [/search?q=keywords:fuzzy]\\n * prefix [/search?q=keywords:prefix]\\n * auto suggest [/search?q=keywords:auto suggest]\\n * auto complete [/search?q=keywords:auto complete]\\n * index [/search?q=keywords:index]\\n\\n\\n\\n\\n\\n\\n\\n\\nPACKAGE SIDEBAR\\n\\n\\nINSTALL\\n\\nnpm i minisearch\\n\\n\\nREPOSITORY\\n\\nGitgithub.com/lucaong/minisearch [https://github.com/lucaong/minisearch]\\n\\n\\nHOMEPAGE\\n\\nlucaong.github.io/minisearch/ [https://lucaong.github.io/minisearch/]\\n\\n\\nDOWNLOADSWEEKLY DOWNLOADS\\n\\n163,266\\n\\n\\nVERSION\\n\\n6.3.0\\n\\n\\nLICENSE\\n\\nMIT\\n\\n\\nUNPACKED SIZE\\n\\n1.28 MB\\n\\n\\nTOTAL FILES\\n\\n41\\n\\n\\nLAST PUBLISH\\n\\n5 months ago\\n\\n\\nCOLLABORATORS\\n\\n * lucaong\\n   [/npm-avatar/eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdmF0YXJVUkwiOiJodHRwczovL3MuZ3JhdmF0YXIuY29tL2F2YXRhci9lMzc2NTU4NzM4MzYwY2E0M2IxYThiNDNmZmUwYTU4Nj9zaXplPTEwMCZkZWZhdWx0PXJldHJvIn0.B3t7Pj7ZV5OcqFGKsjtyZMlzi3jnXxB2OdMcOyeniFc]/~lucaong\\n\\nTry on RunKit [https://runkit.com/npm/minisearch]\\nReport malware\\n[/support?inquire=security&security-inquire=malware&package=minisearch&version=6.3.0]\\n\\n\\nFOOTER\\n\\nhttps://github.com/npm\\nhttps://github.com\\n\\n\\nSUPPORT\\n\\n * Help [https://docs.npmjs.com]\\n * Advisories [https://github.com/advisories]\\n * Status [http://status.npmjs.org/]\\n * Contact npm [/support]\\n\\n\\nCOMPANY\\n\\n * About [/about]\\n * Blog [https://github.blog/tag/npm/]\\n * Press [/press]\\n\\n\\nTERMS & POLICIES\\n\\n * Policies [/policies/]\\n * Terms of Use [/policies/terms]\\n * Code of Conduct [/policies/conduct]\\n * Privacy [/policies/privacy]\\n\\n\"}"}}